import { OpenAI } from 'openai';
import {
  OPENAI_MODEL_TEXT,
  OPENAI_MODEL_ADVANCED,
  OPENAI_MODEL_LATEST,
  OPENAI_MODEL_REASONING,
  MEDICAL_AI_MODELS,
  TEMPERATURE_CONFIG,
  TOKEN_LIMITS,
  ERROR_MESSAGES,
  VALIDATION_RULES
} from '../constants';
import { 
  GroundingMetadata, 
  ClinicalAnalysisResult,
  EvidenceConsultationRequest,
  EvidenceSearchResult,
  ClinicalFinding,
  ClinicalRecommendation
} from '../../types';

// =============================================================================
// CONFIGURACI√ìN Y VALIDACI√ìN OPTIMIZADA
// =============================================================================

// Configuraci√≥n de OpenAI optimizada para rendimiento
const API_KEY = process.env.NEXT_PUBLIC_OPENAI_API_KEY;

if (!API_KEY) {
  console.error("‚ùå NEXT_PUBLIC_OPENAI_API_KEY no est√° configurada. Por favor verifica tu archivo .env");
  console.error("La aplicaci√≥n podr√≠a no funcionar correctamente sin esta clave.");
}

// Cliente OpenAI optimizado para velocidad
const openai = new OpenAI({
  apiKey: API_KEY || '',
  dangerouslyAllowBrowser: true,
  timeout: 15000, // Reducido de 35s a 15s para mejor UX
  maxRetries: 1, // Reducido de 2 a 1 para evitar esperas largas
});

// =============================================================================
// SISTEMA DE CACHE OPTIMIZADO
// =============================================================================

// Cache in-memory optimizado para respuestas de IA
const responseCache = new Map<string, { response: any; timestamp: number; }>();
const CACHE_DURATION = 15 * 60 * 1000; // 15 minutos (aumentado de lo que hab√≠a impl√≠cito)

// Generar clave de cache m√°s eficiente
const generateCacheKey = (functionName: string, ...args: any[]): string => {
  // Usar hash simple en lugar de JSON.stringify para mejor rendimiento
  const argsHash = args.map(arg => {
    if (typeof arg === 'string') {
      return arg.length > 100 ? arg.substring(0, 100) + `_len${arg.length}` : arg;
    }
    return typeof arg + '_' + String(arg).substring(0, 50);
  }).join('|');
  
  return `${functionName}:${argsHash}`;
};

// Cache inteligente con limpieza autom√°tica
const getCachedResponse = (key: string) => {
  const cached = responseCache.get(key);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.response;
  }
  if (cached) {
    responseCache.delete(key); // Limpiar cache expirado
  }
  return null;
};

const setCachedResponse = (key: string, response: any) => {
  // Limitar tama√±o del cache (m√°ximo 100 entradas)
  if (responseCache.size >= 100) {
    const oldestKey = responseCache.keys().next().value;
    if (oldestKey) {
      responseCache.delete(oldestKey);
    }
  }
  
  responseCache.set(key, { response, timestamp: Date.now() });
};

// =============================================================================
// UTILIDADES OPTIMIZADAS
// =============================================================================

// Funci√≥n optimizada para crear mensajes
const createMessages = (systemMessage: string, userMessage: string) => {
  return [
    { role: "system" as const, content: systemMessage },
    { role: "user" as const, content: userMessage }
  ];
};

// =============================================================================
// PROTECCI√ìN CONTRA LLAMADAS DUPLICADAS OPTIMIZADA
// =============================================================================

// Mapa optimizado de promesas pendientes
const pendingRequests = new Map<string, Promise<any>>();

// Protecci√≥n contra llamadas duplicadas optimizada
const preventDuplicateRequests = async <T>(key: string, requestFn: () => Promise<T>): Promise<T> => {
  // Si ya hay una petici√≥n pendiente, devolver esa promesa
  if (pendingRequests.has(key)) {
    return pendingRequests.get(key) as Promise<T>;
  }

  // Crear nueva promesa con limpieza autom√°tica
  const promise = requestFn().finally(() => {
    pendingRequests.delete(key);
  });

  pendingRequests.set(key, promise);
  return promise;
};

// Validaciones optimizadas (ejecutar solo una vez por funci√≥n)
const validateApiKey = (): void => {
  if (!API_KEY) {
    throw new Error(ERROR_MESSAGES.OPENAI_API_KEY_MISSING);
  }
};

const validateInput = (input: string, minLength: number = 1): void => {
  if (!input || input.trim().length < minLength) {
    throw new Error('Input inv√°lido: el texto debe tener al menos ' + minLength + ' caracteres');
  }
};

const validateTemplateInput = (templateContent: string, patientInfo: string): void => {
  validateInput(templateContent, 10);
  validateInput(patientInfo, VALIDATION_RULES.MIN_PATIENT_INFO_LENGTH);
  
  if (patientInfo.length > VALIDATION_RULES.MAX_PATIENT_INFO_LENGTH) {
    throw new Error('La informaci√≥n del paciente es demasiado larga');
  }
};

const validateClinicalInput = (clinicalInput: string): void => {
  validateInput(clinicalInput, VALIDATION_RULES.MIN_CLINICAL_INFO_LENGTH);
  
  if (clinicalInput.length > VALIDATION_RULES.MAX_CLINICAL_INFO_LENGTH) {
    throw new Error('La informaci√≥n cl√≠nica es demasiado larga');
  }
};

// Funci√≥n optimizada para manejar errores de OpenAI
const handleOpenAIError = (error: unknown, context: string): Error => {
  console.error(`Error en ${context}:`, error);
  
  if (error instanceof Error) {
    // Manejar errores espec√≠ficos de OpenAI
    if (error.message.includes('API key')) {
      return new Error(ERROR_MESSAGES.OPENAI_API_KEY_MISSING);
    }
    if (error.message.includes('rate limit')) {
      return new Error('L√≠mite de API excedido. Intenta en unos momentos.');
    }
    if (error.message.includes('timeout') || error.message.includes('timed out') || error.message.includes('Request timed out')) {
      return new Error('Tiempo de espera agotado. Intenta con contenido m√°s breve.');
    }
    if (error.message.includes('network') || error.message.includes('fetch')) {
      return new Error('Error de conexi√≥n. Verifica tu internet.');
    }
    if (error.message.includes('invalid_request_error')) {
      return new Error('Contenido demasiado largo.');
    }
    if (error.message.includes('context_length_exceeded')) {
      return new Error('Contenido excede el l√≠mite de contexto.');
    }
    return new Error(`Error en ${context}: ${error.message}`);
  }
  
  return new Error(`Error desconocido en ${context}`);
};

// =============================================================================
// SERVICIOS PRINCIPALES OPTIMIZADOS
// =============================================================================

export const generateNoteFromTemplate = async (
  specialtyName: string,
  templateContent: string,
  patientInfo: string
): Promise<{ text: string; groundingMetadata?: GroundingMetadata }> => {
  validateApiKey();
  validateTemplateInput(templateContent, patientInfo);
  
  // Generar clave de cache optimizada
  const cacheKey = generateCacheKey('generateNoteFromTemplate', specialtyName, templateContent, patientInfo);
  
  // Verificar cache primero
  const cached = getCachedResponse(cacheKey);
  if (cached) {
    console.log('üìã Respuesta obtenida desde cache');
    return cached;
  }

  // Usar protecci√≥n contra llamadas duplicadas
  return preventDuplicateRequests(cacheKey, async () => {
    // Prompt optimizado - m√°s conciso pero igual de efectivo
    const prompt = `Completa esta nota m√©dica usando SOLO la informaci√≥n del paciente proporcionada.

INFORMACI√ìN DEL PACIENTE:
"${patientInfo}"

PLANTILLA (formato √∫nicamente):
---
${templateContent}
---

INSTRUCCIONES:
1. Usa √öNICAMENTE la informaci√≥n del paciente
2. NO uses datos de ejemplo de la plantilla
3. Si falta informaci√≥n, omite la secci√≥n o marca "No reportado"
4. Mant√©n el formato estructurado de la plantilla
5. S√© conciso pero completo

Genera la nota m√©dica completada:`;

    try {
      const model = 'gpt-4o-mini';
      const systemMessage = "Asistente m√©dico experto en notas cl√≠nicas. Usa solo informaci√≥n del paciente real, nunca datos de ejemplo de plantillas.";
      
      const messages = createMessages(systemMessage, prompt);
      
      const params = {
        model,
        messages,
        temperature: TEMPERATURE_CONFIG.CRITICAL_MEDICAL,
        max_tokens: TOKEN_LIMITS.CRITICAL_MEDICAL_NOTE,
        top_p: 0.9
      };
      
      const response = await openai.chat.completions.create(params);

      const generatedText = response.choices[0]?.message?.content || '';
      
      if (!generatedText.trim()) {
        throw new Error('No se pudo generar contenido v√°lido');
      }

      const result = { 
        text: generatedText, 
        groundingMetadata: undefined
      };
      
      // Guardar en cache
      setCachedResponse(cacheKey, result);
      
      return result;
    } catch (error) {
      throw handleOpenAIError(error, 'generaci√≥n de nota con plantilla');
    }
  });
};

export const generateMedicalScale = async (
  clinicalInput: string,
  scaleName: string
): Promise<{ text: string; groundingMetadata?: GroundingMetadata }> => {
  validateApiKey();
  validateClinicalInput(clinicalInput);
  validateInput(scaleName, 2);

  // Verificar cache
  const cacheKey = generateCacheKey('generateMedicalScale', clinicalInput, scaleName);
  const cached = getCachedResponse(cacheKey);
  if (cached) {
    console.log('üéØ Escala obtenida desde cache');
    return cached;
  }

  // Prompt optimizado para escalas m√©dicas
  const prompt = `Eval√∫a la escala "${scaleName}" con la informaci√≥n cl√≠nica disponible.

INFORMACI√ìN CL√çNICA:
"${clinicalInput}"

ESCALA: ${scaleName}

INSTRUCCIONES:
1. Eval√∫a solo con informaci√≥n expl√≠cita disponible
2. Si falta informaci√≥n, marca "Informaci√≥n insuficiente"
3. NO hagas inferencias m√°s all√° de lo mencionado
4. Proporciona puntaje total solo si es representativo
5. Incluye limitaciones por datos faltantes

FORMATO:
ESCALA ${scaleName}:
√çtem 1: [Puntaje] - [Justificaci√≥n]
√çtem 2: Informaci√≥n insuficiente - Falta: [dato necesario]
...
PUNTAJE TOTAL: [X/Y puntos] ([Z]% completada)
INTERPRETACI√ìN: [Solo si hay suficiente informaci√≥n]
LIMITACIONES: [Datos faltantes que afectan la evaluaci√≥n]`;

  try {
    const model = 'gpt-4o-mini';
    const systemMessage = "Experto en escalas cl√≠nicas. Solo usa informaci√≥n expl√≠cita, nunca inventa datos. Transparente sobre limitaciones.";
    
    const messages = createMessages(systemMessage, prompt);
    
    const params = {
      model,
      messages,
      temperature: TEMPERATURE_CONFIG.CLINICAL_REASONING,
      max_tokens: TOKEN_LIMITS.MEDICAL_SCALE,
      top_p: 0.9
    };
    
    const response = await openai.chat.completions.create(params);

    const result = response.choices[0]?.message?.content || '';
    
    if (!result.trim()) {
      throw new Error('No se pudo generar contenido v√°lido');
    }
    
    const finalResult = {
      text: result,
      groundingMetadata: { groundingChunks: [] }
    };
    
    // Guardar en cache
    setCachedResponse(cacheKey, finalResult);
    
    return finalResult;
  } catch (error) {
    throw handleOpenAIError(error, 'generaci√≥n de escala m√©dica');
  }
};

export const updateClinicalNote = async (
  originalNote: string,
  newInformation: string
): Promise<{ text: string; groundingMetadata?: GroundingMetadata }> => {
  validateApiKey();

  // Verificar cache
  const cacheKey = generateCacheKey('updateClinicalNote', originalNote, newInformation);
  const cached = getCachedResponse(cacheKey);
  if (cached) {
    console.log('üìù Actualizaci√≥n obtenida desde cache');
    return cached;
  }

  // Prompt optimizado para actualizaci√≥n de notas
  const prompt = `Actualiza esta nota cl√≠nica integrando √öNICAMENTE la nueva informaci√≥n proporcionada.

**NOTA ORIGINAL:**
---
${originalNote}
---

**NUEVA INFORMACI√ìN:**
---
${newInformation}
---

INSTRUCCIONES:
1. Preserva el formato y estructura exactos de la nota original
2. Integra SOLO la nueva informaci√≥n proporcionada
3. NO reescribas secciones que no requieren actualizaci√≥n
4. Mant√©n el mismo estilo de redacci√≥n m√©dica
5. Si la nueva informaci√≥n reemplaza datos existentes, reemplaza SOLO esos datos espec√≠ficos

Devuelve la nota cl√≠nica completa actualizada:`;

  try {
    const model = 'gpt-4o-mini';
    const systemMessage = "Especialista en actualizaci√≥n selectiva de notas cl√≠nicas. Preserva estructura original, modifica solo lo necesario.";
    
    const messages = createMessages(systemMessage, prompt);
    
    const params = {
      model,
      messages,
      temperature: TEMPERATURE_CONFIG.CRITICAL_MEDICAL,
      max_tokens: TOKEN_LIMITS.CRITICAL_MEDICAL_NOTE,
      top_p: 0.8
    };
    
    const response = await openai.chat.completions.create(params);

    const generatedText = response.choices[0]?.message?.content || '';
    
    const result = { 
      text: generatedText, 
      groundingMetadata: undefined
    };
    
    // Guardar en cache
    setCachedResponse(cacheKey, result);
    
    return result;
  } catch (error) {
    throw handleOpenAIError(error, 'actualizaci√≥n selectiva de nota cl√≠nica');
  }
}; 

// ===== AN√ÅLISIS CL√çNICO OPTIMIZADO =====

export const analyzeClinicalContent = async (
  request: EvidenceConsultationRequest
): Promise<ClinicalAnalysisResult> => {
  validateApiKey();

  // Verificar cache
  const cacheKey = generateCacheKey('analyzeClinicalContent', request.clinicalContent, request.consultationType);
  const cached = getCachedResponse(cacheKey);
  if (cached) {
    console.log('üî¨ An√°lisis obtenido desde cache');
    return cached;
  }

  // Prompt optimizado para an√°lisis cl√≠nico
  const prompt = `Analiza este contenido cl√≠nico y genera recomendaciones basadas en evidencia.

CONTENIDO CL√çNICO:
---
${request.clinicalContent}
---

TIPO: ${request.consultationType}
${request.focusAreas ? `√ÅREAS DE ENFOQUE: ${request.focusAreas.join(', ')}` : ''}

${request.patientContext ? `CONTEXTO DEL PACIENTE:
- Edad: ${request.patientContext.age || 'No especificada'}
- Sexo: ${request.patientContext.sex || 'No especificado'}
- Comorbilidades: ${request.patientContext.comorbidities?.join(', ') || 'Ninguna'}
- Alergias: ${request.patientContext.allergies?.join(', ') || 'Ninguna'}
- Medicamentos: ${request.patientContext.currentMedications?.join(', ') || 'Ninguno'}` : ''}

INSTRUCCIONES:
1. Extrae hallazgos cl√≠nicos principales
2. Genera recomendaciones basadas en evidencia
3. Identifica factores de riesgo y banderas rojas
4. Sugiere plan diagn√≥stico

RESPUESTA EN JSON:
{
  "findings": [{"id": "f1", "category": "symptom", "description": "...", "severity": "moderate", "confidence": 0.8, "extractedText": "..."}],
  "recommendations": [{"id": "r1", "category": "diagnostic", "title": "...", "description": "...", "strength": "strong", "evidenceQuality": "high", "applicability": 0.9, "urgency": "routine", "sources": [{"type": "pubmed", "title": "...", "evidenceLevel": "A"}]}],
  "riskFactors": ["..."],
  "redFlags": ["..."],
  "differentialDiagnoses": ["..."],
  "suggestedWorkup": ["..."],
  "confidence": 0.85,
  "analysisTimestamp": "${new Date().toISOString()}",
  "disclaimerText": "Esta informaci√≥n es para apoyo educativo y no sustituye el juicio cl√≠nico profesional."
}`;

  try {
    const model = 'gpt-4o-mini';
    const systemMessage = "Experto en an√°lisis cl√≠nico basado en evidencia. Responde siempre en JSON v√°lido con recomendaciones precisas.";
    
    const messages = createMessages(systemMessage, prompt);
    
    const params = {
      model,
      messages,
      temperature: TEMPERATURE_CONFIG.CLINICAL_REASONING,
      max_tokens: TOKEN_LIMITS.CLINICAL_ANALYSIS,
      top_p: 0.8
    };
    
    const response = await openai.chat.completions.create(params);

    const responseText = response.choices[0]?.message?.content || '';
    
    try {
      const parsed = JSON.parse(responseText);
      
      // Validar estructura m√≠nima
      if (!parsed.findings || !parsed.recommendations) {
        throw new Error('Respuesta de IA inv√°lida: falta estructura de an√°lisis');
      }

      // Guardar en cache
      setCachedResponse(cacheKey, parsed);
      
      return parsed as ClinicalAnalysisResult;
    } catch (jsonError) {
      console.error('Error parsing clinical analysis response:', jsonError);
      throw new Error('La IA no pudo generar un an√°lisis v√°lido. Intenta con informaci√≥n cl√≠nica m√°s espec√≠fica.');
    }
  } catch (error) {
    throw handleOpenAIError(error, 'an√°lisis de contenido cl√≠nico');
  }
};

export const searchEvidenceBasedRecommendations = async (
  query: string,
  clinicalContext?: string
): Promise<EvidenceSearchResult> => {
  validateApiKey();

  // Verificar cache
  const cacheKey = generateCacheKey('searchEvidenceBasedRecommendations', query, clinicalContext || '');
  const cached = getCachedResponse(cacheKey);
  if (cached) {
    console.log('üîç B√∫squeda obtenida desde cache');
    return cached;
  }

  // Prompt optimizado para b√∫squeda de evidencia
  const prompt = `Busca evidencia cient√≠fica para: "${query}"

${clinicalContext ? `CONTEXTO CL√çNICO:
---
${clinicalContext}
---` : ''}

INSTRUCCIONES:
1. Busca evidencia espec√≠fica para la consulta
2. Prioriza fuentes de alta calidad
3. Proporciona recomendaciones pr√°cticas
4. Incluye niveles de evidencia

RESPUESTA EN JSON:
{
  "query": "${query}",
  "sources": [{"type": "pubmed", "title": "...", "authors": ["..."], "journal": "...", "year": 2023, "evidenceLevel": "A", "studyType": "meta_analysis"}],
  "recommendations": [{"id": "sr1", "category": "therapeutic", "title": "...", "description": "...", "strength": "strong", "evidenceQuality": "high", "applicability": 0.85, "urgency": "routine"}],
  "searchTimestamp": "${new Date().toISOString()}",
  "totalResults": 5,
  "searchStrategy": "B√∫squeda en bases de datos m√©dicas principales"
}`;

  try {
    const model = 'gpt-4o-mini';
    const systemMessage = "Experto en medicina basada en evidencia. Responde en JSON v√°lido con informaci√≥n cient√≠ficamente respaldada.";
    
    const messages = createMessages(systemMessage, prompt);
    
    const params = {
      model,
      messages,
      temperature: TEMPERATURE_CONFIG.EVIDENCE_SUGGESTIONS,
      max_tokens: TOKEN_LIMITS.EVIDENCE_SUGGESTIONS,
      top_p: 0.8
    };
    
    const response = await openai.chat.completions.create(params);

    const responseText = response.choices[0]?.message?.content || '';
    
    try {
      const parsed = JSON.parse(responseText);
      
      // Guardar en cache
      setCachedResponse(cacheKey, parsed);
      
      return parsed as EvidenceSearchResult;
    } catch (jsonError) {
      console.error('Error parsing evidence search response:', jsonError);
      throw new Error('La IA no pudo generar resultados de b√∫squeda v√°lidos.');
    }
  } catch (error) {
    throw handleOpenAIError(error, 'b√∫squeda de recomendaciones basadas en evidencia');
  }
};

export const generateEvidenceBasedConsultation = async (
  clinicalContent: string,
  specificQuestions?: string[]
): Promise<{ analysis: ClinicalAnalysisResult; evidenceSearch?: EvidenceSearchResult }> => {
  validateApiKey();

  // Configurar la solicitud de consulta
  const consultationRequest: EvidenceConsultationRequest = {
    clinicalContent,
    consultationType: 'comprehensive',
    focusAreas: specificQuestions
  };

  try {
    // Realizar an√°lisis cl√≠nico completo
    const analysis = await analyzeClinicalContent(consultationRequest);

    // Si hay preguntas espec√≠ficas, realizar b√∫squeda adicional
    let evidenceSearch: EvidenceSearchResult | undefined;
    if (specificQuestions && specificQuestions.length > 0) {
      const combinedQuery = specificQuestions.join(' AND ');
      evidenceSearch = await searchEvidenceBasedRecommendations(combinedQuery, clinicalContent);
    }

    return {
      analysis,
      evidenceSearch
    };
  } catch (error) {
    throw handleOpenAIError(error, 'generaci√≥n de consulta basada en evidencia');
  }
};

export const formatEvidenceBasedReport = async (
  analysisResult: ClinicalAnalysisResult,
  evidenceSearch?: EvidenceSearchResult,
  includeReferences: boolean = true
): Promise<string> => {
  let report = `**CONSULTA CL√çNICA BASADA EN EVIDENCIA**\n\n`;
  
  // Timestamp
  report += `Fecha del an√°lisis: ${new Date(analysisResult.analysisTimestamp).toLocaleString('es-ES')}\n`;
  report += `Confianza del an√°lisis: ${Math.round(analysisResult.confidence * 100)}%\n\n`;

  // Hallazgos cl√≠nicos principales
  if (analysisResult.findings.length > 0) {
    report += `**HALLAZGOS CL√çNICOS IDENTIFICADOS:**\n`;
    analysisResult.findings.forEach((finding, index) => {
      report += `${index + 1}. **${finding.category.toUpperCase()}**: ${finding.description}\n`;
      if (finding.severity) {
        report += `   - Severidad: ${finding.severity}\n`;
      }
      report += `   - Confianza: ${Math.round(finding.confidence * 100)}%\n\n`;
    });
  }

  // Banderas rojas
  if (analysisResult.redFlags.length > 0) {
    report += `**üö© BANDERAS ROJAS - ATENCI√ìN INMEDIATA:**\n`;
    analysisResult.redFlags.forEach(flag => {
      report += `‚Ä¢ ${flag}\n`;
    });
    report += `\n`;
  }

  // Recomendaciones principales
  if (analysisResult.recommendations.length > 0) {
    report += `**RECOMENDACIONES BASADAS EN EVIDENCIA:**\n\n`;
    
    // Agrupar por urgencia
    const immediateRecs = analysisResult.recommendations.filter(r => r.urgency === 'immediate');
    const urgentRecs = analysisResult.recommendations.filter(r => r.urgency === 'urgent');
    const routineRecs = analysisResult.recommendations.filter(r => r.urgency === 'routine');

    if (immediateRecs.length > 0) {
      report += `**INMEDIATAS:**\n`;
      immediateRecs.forEach((rec, index) => {
        report += `${index + 1}. **${rec.title}**\n`;
        report += `   ${rec.description}\n`;
        report += `   - Fuerza: ${rec.strength} | Calidad evidencia: ${rec.evidenceQuality}\n`;
        if (rec.contraindications && rec.contraindications.length > 0) {
          report += `   - Contraindicaciones: ${rec.contraindications.join(', ')}\n`;
        }
        report += `\n`;
      });
    }

    if (urgentRecs.length > 0) {
      report += `**URGENTES:**\n`;
      urgentRecs.forEach((rec, index) => {
        report += `${index + 1}. **${rec.title}**\n`;
        report += `   ${rec.description}\n`;
        report += `   - Fuerza: ${rec.strength} | Calidad evidencia: ${rec.evidenceQuality}\n\n`;
      });
    }

    if (routineRecs.length > 0) {
      report += `**RUTINARIAS:**\n`;
      routineRecs.forEach((rec, index) => {
        report += `${index + 1}. **${rec.title}**\n`;
        report += `   ${rec.description}\n`;
        report += `   - Fuerza: ${rec.strength} | Calidad evidencia: ${rec.evidenceQuality}\n\n`;
      });
    }
  }

  // Diagn√≥sticos diferenciales
  if (analysisResult.differentialDiagnoses.length > 0) {
    report += `**DIAGN√ìSTICOS DIFERENCIALES A CONSIDERAR:**\n`;
    analysisResult.differentialDiagnoses.forEach(dx => {
      report += `‚Ä¢ ${dx}\n`;
    });
    report += `\n`;
  }

  // Plan diagn√≥stico sugerido
  if (analysisResult.suggestedWorkup.length > 0) {
    report += `**PLAN DIAGN√ìSTICO SUGERIDO:**\n`;
    analysisResult.suggestedWorkup.forEach(study => {
      report += `‚Ä¢ ${study}\n`;
    });
    report += `\n`;
  }

  // Referencias principales (si se incluyen)
  if (includeReferences && analysisResult.recommendations.length > 0) {
    const allSources = analysisResult.recommendations
      .flatMap(rec => rec.sources)
      .filter((source, index, self) => 
        index === self.findIndex(s => s.title === source.title)
      );

    if (allSources.length > 0) {
      report += `**REFERENCIAS PRINCIPALES:**\n`;
      allSources.forEach((source, index) => {
        report += `${index + 1}. ${source.title}`;
        if (source.authors && source.authors.length > 0) {
          report += ` - ${source.authors.join(', ')}`;
        }
        if (source.journal && source.year) {
          report += ` (${source.journal}, ${source.year})`;
        }
        report += ` [Nivel evidencia: ${source.evidenceLevel}]\n`;
      });
      report += `\n`;
    }
  }

  // Evidencia adicional si existe
  if (evidenceSearch && evidenceSearch.recommendations.length > 0) {
    report += `**EVIDENCIA ADICIONAL ENCONTRADA:**\n`;
    evidenceSearch.recommendations.forEach((rec, index) => {
      report += `${index + 1}. ${rec.title}: ${rec.description}\n`;
    });
    report += `\n`;
  }

  // Disclaimer
  report += `**IMPORTANTE:**\n${analysisResult.disclaimerText}\n`;

  return report;
}; 

// ===== CONSULTA CL√çNICA SIMPLIFICADA OPTIMIZADA =====

export const generateSimplifiedEvidenceConsultation = async (
  clinicalContent: string
): Promise<{ text: string; groundingMetadata?: GroundingMetadata }> => {
  validateApiKey();
  
  // Verificar cache
  const cacheKey = generateCacheKey('generateSimplifiedEvidenceConsultation', clinicalContent);
  const cached = getCachedResponse(cacheKey);
  if (cached) {
    console.log('ü©∫ Consulta obtenida desde cache');
    return cached;
  }

  // Usar protecci√≥n contra llamadas duplicadas
  return preventDuplicateRequests(cacheKey, async () => {
    // Prompt optimizado para consulta simplificada
    const prompt = `Analiza este contenido cl√≠nico y proporciona recomendaciones basadas en evidencia cient√≠fica.

CONTENIDO CL√çNICO:
---
${clinicalContent}
---

INSTRUCCIONES:
1. **AN√ÅLISIS:** Identifica hallazgos principales y aspectos relevantes
2. **RECOMENDACIONES:** Sugerencias diagn√≥sticas y terap√©uticas con evidencia
3. **CITAS:** Referencias a estudios recientes y gu√≠as cl√≠nicas relevantes
4. **FORMATO:** Estructura profesional con citas integradas

FUENTES PRINCIPALES: PubMed, Cochrane, UpToDate, NEJM, The Lancet, JAMA, BMJ

Proporciona an√°lisis completo con recomendaciones pr√°cticas para la toma de decisiones cl√≠nicas.`;

    try {
      const model = 'gpt-4o-mini';
      const systemMessage = "M√©dico especialista en medicina basada en evidencia. An√°lisis cl√≠nicos con recomendaciones respaldadas por literatura cient√≠fica actual.";
      
      const messages = createMessages(systemMessage, prompt);
      
      const params = {
        model,
        messages,
        temperature: TEMPERATURE_CONFIG.CONSULTATION,
        max_tokens: TOKEN_LIMITS.CONSULTATION,
        top_p: 0.9
      };
      
      const response = await openai.chat.completions.create(params);

      const result = response.choices[0]?.message?.content || '';
      
      if (!result.trim()) {
        throw new Error('No se pudo generar contenido v√°lido');
      }
      
      const finalResult = {
        text: result,
        groundingMetadata: { groundingChunks: [] }
      };
      
      // Guardar en cache
      setCachedResponse(cacheKey, finalResult);
      
      return finalResult;
    } catch (error) {
      throw handleOpenAIError(error, 'generaci√≥n de consulta basada en evidencia simplificada');
    }
  });
};

// =============================================================================
// UTILIDADES
// =============================================================================

export const validateOpenAIConfiguration = (): boolean => {
  return Boolean(API_KEY);
};

export const getOpenAIModelInfo = () => {
  return {
    textModel: OPENAI_MODEL_TEXT,
    advancedModel: OPENAI_MODEL_ADVANCED,
    latestModel: OPENAI_MODEL_LATEST,
    reasoningModel: OPENAI_MODEL_REASONING,
    medicalModels: MEDICAL_AI_MODELS,
    temperatureConfig: TEMPERATURE_CONFIG,
    tokenLimits: TOKEN_LIMITS,
  };
}; 